
GccAplicacaoPlantGuard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000005f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000582  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  000005f6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005f6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000628  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000a0  00000000  00000000  00000668  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000c76  00000000  00000000  00000708  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000087b  00000000  00000000  0000137e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005a6  00000000  00000000  00001bf9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001e0  00000000  00000000  000021a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000054d  00000000  00000000  00002380  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004e9  00000000  00000000  000028cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00002db6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   8:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 48 00 	jmp	0x90	; 0x90 <__vector_14>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	21 e0       	ldi	r18, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	a1 30       	cpi	r26, 0x01	; 1
  80:	b2 07       	cpc	r27, r18
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <main>
  88:	0c 94 bf 02 	jmp	0x57e	; 0x57e <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <__vector_14>:
void verifica_acao_motor(void);                                               // Verifica e processa comandos recebidos via UART para o motor.
int ler_sensor_e_atualizar(void);                                             // Função principal da lógica: lê o sensor e atualiza os atuadores (LEDs, buzzer).

// ---------- INTERRUP��O DO TIMER0 (BUZZER) ----------
ISR(TIMER0_COMPA_vect)
{
  90:	1f 92       	push	r1
  92:	0f 92       	push	r0
  94:	0f b6       	in	r0, 0x3f	; 63
  96:	0f 92       	push	r0
  98:	11 24       	eor	r1, r1
  9a:	8f 93       	push	r24
    if (alarmOn)
  9c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  a0:	88 23       	and	r24, r24
  a2:	21 f0       	breq	.+8      	; 0xac <__vector_14+0x1c>
    {
        PORTD ^= (1 << BUZZER_PIN); // Alterna o pino � gera o som
  a4:	8b b1       	in	r24, 0x0b	; 11
  a6:	80 58       	subi	r24, 0x80	; 128
  a8:	8b b9       	out	0x0b, r24	; 11
  aa:	03 c0       	rjmp	.+6      	; 0xb2 <__vector_14+0x22>
    }
    else
    {
        PORTD &= ~(1 << BUZZER_PIN); // Garante buzzer desligado
  ac:	8b b1       	in	r24, 0x0b	; 11
  ae:	8f 77       	andi	r24, 0x7F	; 127
  b0:	8b b9       	out	0x0b, r24	; 11
    }
}
  b2:	8f 91       	pop	r24
  b4:	0f 90       	pop	r0
  b6:	0f be       	out	0x3f, r0	; 63
  b8:	0f 90       	pop	r0
  ba:	1f 90       	pop	r1
  bc:	18 95       	reti

000000be <setup_uart>:
    }
}

void setup_uart(unsigned int ubrr)
{
    UBRR0H = (unsigned char)(ubrr >> 8);    // Baud rate parte alta
  be:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
    UBRR0L = (unsigned char)ubrr;           // Baud rate parte baixa
  c2:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
    UCSR0B = (1 << RXEN0) | (1 << TXEN0);   // Habilita RX e TX
  c6:	88 e1       	ldi	r24, 0x18	; 24
  c8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // 8 bits
  cc:	86 e0       	ldi	r24, 0x06	; 6
  ce:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
  d2:	08 95       	ret

000000d4 <uart_transmit>:
}

void uart_transmit(unsigned char data)
{
    while (!(UCSR0A & (1 << UDRE0)))
  d4:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  d8:	95 ff       	sbrs	r25, 5
  da:	fc cf       	rjmp	.-8      	; 0xd4 <uart_transmit>
        ;        // Espera buffer liberar
    UDR0 = data; // Envia o byte
  dc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
  e0:	08 95       	ret

000000e2 <uart_print_text>:
    }
}

// ---------- FUN��ES UART ----------
void uart_print_text(const char *str)
{
  e2:	cf 93       	push	r28
  e4:	df 93       	push	r29
  e6:	ec 01       	movw	r28, r24
    while (*str)
  e8:	03 c0       	rjmp	.+6      	; 0xf0 <uart_print_text+0xe>
    {
        uart_transmit(*str++);
  ea:	21 96       	adiw	r28, 0x01	; 1
  ec:	0e 94 6a 00 	call	0xd4	; 0xd4 <uart_transmit>
}

// ---------- FUN��ES UART ----------
void uart_print_text(const char *str)
{
    while (*str)
  f0:	88 81       	ld	r24, Y
  f2:	81 11       	cpse	r24, r1
  f4:	fa cf       	rjmp	.-12     	; 0xea <uart_print_text+0x8>
    {
        uart_transmit(*str++);
    }
}
  f6:	df 91       	pop	r29
  f8:	cf 91       	pop	r28
  fa:	08 95       	ret

000000fc <uart_available>:
    UDR0 = data; // Envia o byte
}

int uart_available(void)
{
    return (UCSR0A & (1 << RXC0)); // Retorna 1 se chegou dado
  fc:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
 100:	80 78       	andi	r24, 0x80	; 128
}
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	08 95       	ret

00000106 <setup_gpio>:

// ---------- GPIO ----------
void setup_gpio(void)
{
    // LEDs e servo como sa�da
    DDRB |= (1 << LED_VERDE) | (1 << SERVO_PIN) | (1 << LED_VERMELHO) | (1 << LED_ACAO);
 106:	84 b1       	in	r24, 0x04	; 4
 108:	87 62       	ori	r24, 0x27	; 39
 10a:	84 b9       	out	0x04, r24	; 4

    // LEDs e buzzer no PORTD
    DDRD |= (1 << LED_STATUS) | (1 << LED_AMARELO) | (1 << BUZZER_PIN);
 10c:	8a b1       	in	r24, 0x0a	; 10
 10e:	88 69       	ori	r24, 0x98	; 152
 110:	8a b9       	out	0x0a, r24	; 10

    DDRC &= ~(1 << PC0); // PC0 como entrada (LDR)
 112:	87 b1       	in	r24, 0x07	; 7
 114:	8e 7f       	andi	r24, 0xFE	; 254
 116:	87 b9       	out	0x07, r24	; 7
 118:	08 95       	ret

0000011a <setup_adc>:
}

// ---------- ADC ----------
void setup_adc(void)
{
    ADMUX = (1 << REFS0);                                              // Refer�ncia AVCC
 11a:	80 e4       	ldi	r24, 0x40	; 64
 11c:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>
    ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // Prescaler 128
 120:	87 e8       	ldi	r24, 0x87	; 135
 122:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
 126:	08 95       	ret

00000128 <read_adc>:
}

uint16_t read_adc(uint8_t channel)
{
    ADMUX = (ADMUX & 0xF0) | (channel & 0x0F); // Seleciona canal
 128:	ec e7       	ldi	r30, 0x7C	; 124
 12a:	f0 e0       	ldi	r31, 0x00	; 0
 12c:	90 81       	ld	r25, Z
 12e:	90 7f       	andi	r25, 0xF0	; 240
 130:	8f 70       	andi	r24, 0x0F	; 15
 132:	89 2b       	or	r24, r25
 134:	80 83       	st	Z, r24
    ADCSRA |= (1 << ADSC);                     // Inicia convers�o
 136:	ea e7       	ldi	r30, 0x7A	; 122
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	80 81       	ld	r24, Z
 13c:	80 64       	ori	r24, 0x40	; 64
 13e:	80 83       	st	Z, r24
    while (ADCSRA & (1 << ADSC))
 140:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
 144:	86 fd       	sbrc	r24, 6
 146:	fc cf       	rjmp	.-8      	; 0x140 <read_adc+0x18>
        ; // Aguarda
    return ADC;
 148:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7f8078>
 14c:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
}
 150:	08 95       	ret

00000152 <setup_timer0_buzzer>:

// ---------- TIMER0 (BUZZER) ----------
void setup_timer0_buzzer(void)
{
    TCCR0A = (1 << WGM01);              // Modo CTC
 152:	82 e0       	ldi	r24, 0x02	; 2
 154:	84 bd       	out	0x24, r24	; 36
    TCCR0B = (1 << CS01) | (1 << CS00); // Prescaler 64
 156:	93 e0       	ldi	r25, 0x03	; 3
 158:	95 bd       	out	0x25, r25	; 37
    TIMSK0 = (1 << OCIE0A);             // Habilita interrup��o
 15a:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
 15e:	08 95       	ret

00000160 <set_buzzer_freq>:
}

void set_buzzer_freq(uint16_t freq)
{
    if (freq == 0)
 160:	00 97       	sbiw	r24, 0x00	; 0
 162:	19 f4       	brne	.+6      	; 0x16a <set_buzzer_freq+0xa>
    {
        alarmOn = 0;
 164:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
 168:	08 95       	ret
    }
    else
    {
        uint8_t compareValue = (F_CPU / (2UL * 64UL * freq)) - 1;
 16a:	a0 e0       	ldi	r26, 0x00	; 0
 16c:	b0 e0       	ldi	r27, 0x00	; 0
 16e:	88 0f       	add	r24, r24
 170:	99 1f       	adc	r25, r25
 172:	aa 1f       	adc	r26, r26
 174:	bb 1f       	adc	r27, r27
 176:	88 0f       	add	r24, r24
 178:	99 1f       	adc	r25, r25
 17a:	aa 1f       	adc	r26, r26
 17c:	bb 1f       	adc	r27, r27
 17e:	88 0f       	add	r24, r24
 180:	99 1f       	adc	r25, r25
 182:	aa 1f       	adc	r26, r26
 184:	bb 1f       	adc	r27, r27
 186:	88 0f       	add	r24, r24
 188:	99 1f       	adc	r25, r25
 18a:	aa 1f       	adc	r26, r26
 18c:	bb 1f       	adc	r27, r27
 18e:	88 0f       	add	r24, r24
 190:	99 1f       	adc	r25, r25
 192:	aa 1f       	adc	r26, r26
 194:	bb 1f       	adc	r27, r27
 196:	88 0f       	add	r24, r24
 198:	99 1f       	adc	r25, r25
 19a:	aa 1f       	adc	r26, r26
 19c:	bb 1f       	adc	r27, r27
 19e:	9c 01       	movw	r18, r24
 1a0:	ad 01       	movw	r20, r26
 1a2:	22 0f       	add	r18, r18
 1a4:	33 1f       	adc	r19, r19
 1a6:	44 1f       	adc	r20, r20
 1a8:	55 1f       	adc	r21, r21
 1aa:	60 e0       	ldi	r22, 0x00	; 0
 1ac:	74 e2       	ldi	r23, 0x24	; 36
 1ae:	84 ef       	ldi	r24, 0xF4	; 244
 1b0:	90 e0       	ldi	r25, 0x00	; 0
 1b2:	0e 94 2f 02 	call	0x45e	; 0x45e <__udivmodsi4>
 1b6:	21 50       	subi	r18, 0x01	; 1
        OCR0A = compareValue;
 1b8:	27 bd       	out	0x27, r18	; 39
        alarmOn = 1;
 1ba:	81 e0       	ldi	r24, 0x01	; 1
 1bc:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
 1c0:	08 95       	ret

000001c2 <setup_timer1_servo>:
}

// ---------- TIMER1 (SERVO PWM) ----------
void setup_timer1_servo(void)
{
    DDRB |= (1 << SERVO_PIN);
 1c2:	84 b1       	in	r24, 0x04	; 4
 1c4:	82 60       	ori	r24, 0x02	; 2
 1c6:	84 b9       	out	0x04, r24	; 4

    // Fast PWM, TOP = ICR1, prescaler 8
    TCCR1A = (1 << COM1A1) | (1 << WGM11);
 1c8:	82 e8       	ldi	r24, 0x82	; 130
 1ca:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
 1ce:	8a e1       	ldi	r24, 0x1A	; 26
 1d0:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

    ICR1 = 39999;      // Define ciclo de 20ms
 1d4:	8f e3       	ldi	r24, 0x3F	; 63
 1d6:	9c e9       	ldi	r25, 0x9C	; 156
 1d8:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
 1dc:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
    OCR1A = SERVO_MIN; // Posi��o inicial
 1e0:	80 ed       	ldi	r24, 0xD0	; 208
 1e2:	97 e0       	ldi	r25, 0x07	; 7
 1e4:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 1e8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 1ec:	08 95       	ret

000001ee <map_value>:
}

// ---------- FUN��ES GERAIS ----------
long map_value(long x, long in_min, long in_max, long out_min, long out_max)
{
 1ee:	4f 92       	push	r4
 1f0:	5f 92       	push	r5
 1f2:	6f 92       	push	r6
 1f4:	7f 92       	push	r7
 1f6:	af 92       	push	r10
 1f8:	bf 92       	push	r11
 1fa:	cf 92       	push	r12
 1fc:	df 92       	push	r13
 1fe:	ef 92       	push	r14
 200:	ff 92       	push	r15
 202:	0f 93       	push	r16
 204:	1f 93       	push	r17
 206:	cf 93       	push	r28
 208:	df 93       	push	r29
 20a:	cd b7       	in	r28, 0x3d	; 61
 20c:	de b7       	in	r29, 0x3e	; 62
 20e:	29 01       	movw	r4, r18
 210:	3a 01       	movw	r6, r20
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 212:	9b 01       	movw	r18, r22
 214:	ac 01       	movw	r20, r24
 216:	24 19       	sub	r18, r4
 218:	35 09       	sbc	r19, r5
 21a:	46 09       	sbc	r20, r6
 21c:	57 09       	sbc	r21, r7
 21e:	89 89       	ldd	r24, Y+17	; 0x11
 220:	9a 89       	ldd	r25, Y+18	; 0x12
 222:	ab 89       	ldd	r26, Y+19	; 0x13
 224:	bc 89       	ldd	r27, Y+20	; 0x14
 226:	bc 01       	movw	r22, r24
 228:	cd 01       	movw	r24, r26
 22a:	6a 19       	sub	r22, r10
 22c:	7b 09       	sbc	r23, r11
 22e:	8c 09       	sbc	r24, r12
 230:	9d 09       	sbc	r25, r13
 232:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsi3>
 236:	a8 01       	movw	r20, r16
 238:	97 01       	movw	r18, r14
 23a:	24 19       	sub	r18, r4
 23c:	35 09       	sbc	r19, r5
 23e:	46 09       	sbc	r20, r6
 240:	57 09       	sbc	r21, r7
 242:	0e 94 51 02 	call	0x4a2	; 0x4a2 <__divmodsi4>
 246:	c6 01       	movw	r24, r12
 248:	b5 01       	movw	r22, r10
 24a:	62 0f       	add	r22, r18
 24c:	73 1f       	adc	r23, r19
 24e:	84 1f       	adc	r24, r20
 250:	95 1f       	adc	r25, r21
}
 252:	df 91       	pop	r29
 254:	cf 91       	pop	r28
 256:	1f 91       	pop	r17
 258:	0f 91       	pop	r16
 25a:	ff 90       	pop	r15
 25c:	ef 90       	pop	r14
 25e:	df 90       	pop	r13
 260:	cf 90       	pop	r12
 262:	bf 90       	pop	r11
 264:	af 90       	pop	r10
 266:	7f 90       	pop	r7
 268:	6f 90       	pop	r6
 26a:	5f 90       	pop	r5
 26c:	4f 90       	pop	r4
 26e:	08 95       	ret

00000270 <apaga_leds>:

void apaga_leds(void)
{
    PORTB &= ~(1 << LED_VERDE);
 270:	85 b1       	in	r24, 0x05	; 5
 272:	8e 7f       	andi	r24, 0xFE	; 254
 274:	85 b9       	out	0x05, r24	; 5
    PORTD &= ~(1 << LED_AMARELO);
 276:	8b b1       	in	r24, 0x0b	; 11
 278:	8f 7e       	andi	r24, 0xEF	; 239
 27a:	8b b9       	out	0x0b, r24	; 11
    PORTB &= ~(1 << LED_VERMELHO);
 27c:	85 b1       	in	r24, 0x05	; 5
 27e:	8b 7f       	andi	r24, 0xFB	; 251
 280:	85 b9       	out	0x05, r24	; 5
    PORTD &= ~(1 << LED_STATUS);
 282:	8b b1       	in	r24, 0x0b	; 11
 284:	87 7f       	andi	r24, 0xF7	; 247
 286:	8b b9       	out	0x0b, r24	; 11
 288:	08 95       	ret

0000028a <pisca_led_status>:
}

void pisca_led_status(void)
{
    PORTD |= (1 << LED_STATUS);
 28a:	8b b1       	in	r24, 0x0b	; 11
 28c:	88 60       	ori	r24, 0x08	; 8
 28e:	8b b9       	out	0x0b, r24	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 290:	8f ef       	ldi	r24, 0xFF	; 255
 292:	9c e7       	ldi	r25, 0x7C	; 124
 294:	01 97       	sbiw	r24, 0x01	; 1
 296:	f1 f7       	brne	.-4      	; 0x294 <pisca_led_status+0xa>
 298:	00 c0       	rjmp	.+0      	; 0x29a <pisca_led_status+0x10>
 29a:	00 00       	nop
    _delay_ms(8);
    PORTD &= ~(1 << LED_STATUS);
 29c:	8b b1       	in	r24, 0x0b	; 11
 29e:	87 7f       	andi	r24, 0xF7	; 247
 2a0:	8b b9       	out	0x0b, r24	; 11
 2a2:	8f ef       	ldi	r24, 0xFF	; 255
 2a4:	9c e7       	ldi	r25, 0x7C	; 124
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	f1 f7       	brne	.-4      	; 0x2a6 <pisca_led_status+0x1c>
 2aa:	00 c0       	rjmp	.+0      	; 0x2ac <pisca_led_status+0x22>
 2ac:	00 00       	nop
 2ae:	08 95       	ret

000002b0 <verifica_acao_motor>:
}

// ---------- COMANDO DO SERVO POR UART ----------
void verifica_acao_motor(void)
{
    if (uart_available())
 2b0:	0e 94 7e 00 	call	0xfc	; 0xfc <uart_available>
 2b4:	89 2b       	or	r24, r25
 2b6:	c9 f0       	breq	.+50     	; 0x2ea <verifica_acao_motor+0x3a>
    {
        char comando = UDR0;
 2b8:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

        if (comando == 'A')
 2bc:	81 34       	cpi	r24, 0x41	; 65
 2be:	51 f4       	brne	.+20     	; 0x2d4 <verifica_acao_motor+0x24>
        {
            PORTB |= (1 << LED_ACAO);
 2c0:	85 b1       	in	r24, 0x05	; 5
 2c2:	80 62       	ori	r24, 0x20	; 32
 2c4:	85 b9       	out	0x05, r24	; 5
            OCR1A = SERVO_MAX; // Abre servo
 2c6:	80 e3       	ldi	r24, 0x30	; 48
 2c8:	91 e1       	ldi	r25, 0x11	; 17
 2ca:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 2ce:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 2d2:	08 95       	ret
        }
        else if (comando == 'F')
 2d4:	86 34       	cpi	r24, 0x46	; 70
 2d6:	49 f4       	brne	.+18     	; 0x2ea <verifica_acao_motor+0x3a>
        {
            PORTB &= ~(1 << LED_ACAO);
 2d8:	85 b1       	in	r24, 0x05	; 5
 2da:	8f 7d       	andi	r24, 0xDF	; 223
 2dc:	85 b9       	out	0x05, r24	; 5
            OCR1A = SERVO_MIN; // Fecha servo
 2de:	80 ed       	ldi	r24, 0xD0	; 208
 2e0:	97 e0       	ldi	r25, 0x07	; 7
 2e2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 2e6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 2ea:	08 95       	ret

000002ec <ler_sensor_e_atualizar>:
    }
}

// ---------- SENSOR LDR / L�GICA DO SISTEMA ----------
int ler_sensor_e_atualizar(void)
{
 2ec:	af 92       	push	r10
 2ee:	bf 92       	push	r11
 2f0:	cf 92       	push	r12
 2f2:	df 92       	push	r13
 2f4:	ef 92       	push	r14
 2f6:	ff 92       	push	r15
 2f8:	0f 93       	push	r16
 2fa:	1f 93       	push	r17
 2fc:	cf 93       	push	r28
 2fe:	df 93       	push	r29
    uint16_t ldrValue = read_adc(0); // L� ADC
 300:	80 e0       	ldi	r24, 0x00	; 0
 302:	0e 94 94 00 	call	0x128	; 0x128 <read_adc>
    int valorLuminosidade = map_value(ldrValue, 0, 1023, 0, 100);
 306:	bc 01       	movw	r22, r24
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	1f 92       	push	r1
 30e:	1f 92       	push	r1
 310:	1f 92       	push	r1
 312:	24 e6       	ldi	r18, 0x64	; 100
 314:	2f 93       	push	r18
 316:	a1 2c       	mov	r10, r1
 318:	b1 2c       	mov	r11, r1
 31a:	65 01       	movw	r12, r10
 31c:	ee 24       	eor	r14, r14
 31e:	ea 94       	dec	r14
 320:	13 e0       	ldi	r17, 0x03	; 3
 322:	f1 2e       	mov	r15, r17
 324:	00 e0       	ldi	r16, 0x00	; 0
 326:	10 e0       	ldi	r17, 0x00	; 0
 328:	20 e0       	ldi	r18, 0x00	; 0
 32a:	30 e0       	ldi	r19, 0x00	; 0
 32c:	a9 01       	movw	r20, r18
 32e:	0e 94 f7 00 	call	0x1ee	; 0x1ee <map_value>
 332:	0f 90       	pop	r0
 334:	0f 90       	pop	r0
 336:	0f 90       	pop	r0
 338:	0f 90       	pop	r0
 33a:	6b 01       	movw	r12, r22
 33c:	7c 01       	movw	r14, r24
 33e:	eb 01       	movw	r28, r22

    apaga_leds();
 340:	0e 94 38 01 	call	0x270	; 0x270 <apaga_leds>
    set_buzzer_freq(0);
 344:	80 e0       	ldi	r24, 0x00	; 0
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	0e 94 b0 00 	call	0x160	; 0x160 <set_buzzer_freq>

    if (valorLuminosidade <= LIM_MUITO_BAIXA_MAX)
 34c:	c0 31       	cpi	r28, 0x10	; 16
 34e:	d1 05       	cpc	r29, r1
 350:	44 f4       	brge	.+16     	; 0x362 <ler_sensor_e_atualizar+0x76>
    {
        PORTB |= (1 << LED_VERMELHO);
 352:	85 b1       	in	r24, 0x05	; 5
 354:	84 60       	ori	r24, 0x04	; 4
 356:	85 b9       	out	0x05, r24	; 5
        set_buzzer_freq(2000);
 358:	80 ed       	ldi	r24, 0xD0	; 208
 35a:	97 e0       	ldi	r25, 0x07	; 7
 35c:	0e 94 b0 00 	call	0x160	; 0x160 <set_buzzer_freq>
 360:	23 c0       	rjmp	.+70     	; 0x3a8 <ler_sensor_e_atualizar+0xbc>
    }
    else if (valorLuminosidade <= LIM_BAIXA_MAX)
 362:	cf 31       	cpi	r28, 0x1F	; 31
 364:	d1 05       	cpc	r29, r1
 366:	24 f4       	brge	.+8      	; 0x370 <ler_sensor_e_atualizar+0x84>
    {
        PORTB |= (1 << LED_VERMELHO);
 368:	85 b1       	in	r24, 0x05	; 5
 36a:	84 60       	ori	r24, 0x04	; 4
 36c:	85 b9       	out	0x05, r24	; 5
 36e:	1c c0       	rjmp	.+56     	; 0x3a8 <ler_sensor_e_atualizar+0xbc>
    }
    else if (valorLuminosidade <= LIM_MEDIA_MAX)
 370:	c3 33       	cpi	r28, 0x33	; 51
 372:	d1 05       	cpc	r29, r1
 374:	24 f4       	brge	.+8      	; 0x37e <ler_sensor_e_atualizar+0x92>
    {
        PORTD |= (1 << LED_AMARELO);
 376:	8b b1       	in	r24, 0x0b	; 11
 378:	80 61       	ori	r24, 0x10	; 16
 37a:	8b b9       	out	0x0b, r24	; 11
 37c:	15 c0       	rjmp	.+42     	; 0x3a8 <ler_sensor_e_atualizar+0xbc>
    }
    else if (valorLuminosidade <= LIM_IDEAL_MAX)
 37e:	c7 34       	cpi	r28, 0x47	; 71
 380:	d1 05       	cpc	r29, r1
 382:	24 f4       	brge	.+8      	; 0x38c <ler_sensor_e_atualizar+0xa0>
    {
        PORTB |= (1 << LED_VERDE);
 384:	85 b1       	in	r24, 0x05	; 5
 386:	81 60       	ori	r24, 0x01	; 1
 388:	85 b9       	out	0x05, r24	; 5
 38a:	0e c0       	rjmp	.+28     	; 0x3a8 <ler_sensor_e_atualizar+0xbc>
    }
    else if (valorLuminosidade <= LIM_MUITO_ALTA_MIN)
 38c:	cb 35       	cpi	r28, 0x5B	; 91
 38e:	d1 05       	cpc	r29, r1
 390:	24 f4       	brge	.+8      	; 0x39a <ler_sensor_e_atualizar+0xae>
    {
        PORTD |= (1 << LED_AMARELO);
 392:	8b b1       	in	r24, 0x0b	; 11
 394:	80 61       	ori	r24, 0x10	; 16
 396:	8b b9       	out	0x0b, r24	; 11
 398:	07 c0       	rjmp	.+14     	; 0x3a8 <ler_sensor_e_atualizar+0xbc>
    }
    else
    {
        PORTB |= (1 << LED_VERMELHO);
 39a:	85 b1       	in	r24, 0x05	; 5
 39c:	84 60       	ori	r24, 0x04	; 4
 39e:	85 b9       	out	0x05, r24	; 5
        set_buzzer_freq(4000);
 3a0:	80 ea       	ldi	r24, 0xA0	; 160
 3a2:	9f e0       	ldi	r25, 0x0F	; 15
 3a4:	0e 94 b0 00 	call	0x160	; 0x160 <set_buzzer_freq>
    }

    return valorLuminosidade;
}
 3a8:	c6 01       	movw	r24, r12
 3aa:	df 91       	pop	r29
 3ac:	cf 91       	pop	r28
 3ae:	1f 91       	pop	r17
 3b0:	0f 91       	pop	r16
 3b2:	ff 90       	pop	r15
 3b4:	ef 90       	pop	r14
 3b6:	df 90       	pop	r13
 3b8:	cf 90       	pop	r12
 3ba:	bf 90       	pop	r11
 3bc:	af 90       	pop	r10
 3be:	08 95       	ret

000003c0 <main>:
        PORTD &= ~(1 << BUZZER_PIN); // Garante buzzer desligado
    }
}

int main(void)
{
 3c0:	cf 93       	push	r28
 3c2:	df 93       	push	r29
 3c4:	cd b7       	in	r28, 0x3d	; 61
 3c6:	de b7       	in	r29, 0x3e	; 62
 3c8:	2a 97       	sbiw	r28, 0x0a	; 10
 3ca:	0f b6       	in	r0, 0x3f	; 63
 3cc:	f8 94       	cli
 3ce:	de bf       	out	0x3e, r29	; 62
 3d0:	0f be       	out	0x3f, r0	; 63
 3d2:	cd bf       	out	0x3d, r28	; 61
    char stringLuminosidade[10];
    int valorLuminosidade;

    // Inicializa��es
    setup_gpio();
 3d4:	0e 94 83 00 	call	0x106	; 0x106 <setup_gpio>
    setup_adc();
 3d8:	0e 94 8d 00 	call	0x11a	; 0x11a <setup_adc>
    setup_uart(103); // UBRR = 103 ? 9600 baud
 3dc:	87 e6       	ldi	r24, 0x67	; 103
 3de:	90 e0       	ldi	r25, 0x00	; 0
 3e0:	0e 94 5f 00 	call	0xbe	; 0xbe <setup_uart>
    setup_timer0_buzzer();
 3e4:	0e 94 a9 00 	call	0x152	; 0x152 <setup_timer0_buzzer>
    setup_timer1_servo();
 3e8:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <setup_timer1_servo>

    sei(); // Habilita interrup��es globais
 3ec:	78 94       	sei

    apaga_leds();
 3ee:	0e 94 38 01 	call	0x270	; 0x270 <apaga_leds>
    PORTD &= ~(1 << LED_STATUS);
 3f2:	8b b1       	in	r24, 0x0b	; 11
 3f4:	87 7f       	andi	r24, 0xF7	; 247
 3f6:	8b b9       	out	0x0b, r24	; 11

    OCR1A = SERVO_MIN; // Servo come�a fechado
 3f8:	80 ed       	ldi	r24, 0xD0	; 208
 3fa:	97 e0       	ldi	r25, 0x07	; 7
 3fc:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 400:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

    while (1)
    {
        // L� sensor e atualiza LEDs/buzzer
        valorLuminosidade = ler_sensor_e_atualizar();
 404:	0e 94 76 01 	call	0x2ec	; 0x2ec <ler_sensor_e_atualizar>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 408:	4a e0       	ldi	r20, 0x0A	; 10
 40a:	be 01       	movw	r22, r28
 40c:	6f 5f       	subi	r22, 0xFF	; 255
 40e:	7f 4f       	sbci	r23, 0xFF	; 255
 410:	0e 94 8a 02 	call	0x514	; 0x514 <__itoa_ncheck>

        // Converte para texto
        itoa(valorLuminosidade, stringLuminosidade, 10);

        // Envia via UART
        uart_print_text(stringLuminosidade);
 414:	ce 01       	movw	r24, r28
 416:	01 96       	adiw	r24, 0x01	; 1
 418:	0e 94 71 00 	call	0xe2	; 0xe2 <uart_print_text>
        uart_transmit('\n');
 41c:	8a e0       	ldi	r24, 0x0A	; 10
 41e:	0e 94 6a 00 	call	0xd4	; 0xd4 <uart_transmit>

        verifica_acao_motor(); // Processa comandos UART ('A' / 'F')
 422:	0e 94 58 01 	call	0x2b0	; 0x2b0 <verifica_acao_motor>
        pisca_led_status();    // Pisca LED de atividade
 426:	0e 94 45 01 	call	0x28a	; 0x28a <pisca_led_status>
 42a:	2f ef       	ldi	r18, 0xFF	; 255
 42c:	89 e6       	ldi	r24, 0x69	; 105
 42e:	98 e1       	ldi	r25, 0x18	; 24
 430:	21 50       	subi	r18, 0x01	; 1
 432:	80 40       	sbci	r24, 0x00	; 0
 434:	90 40       	sbci	r25, 0x00	; 0
 436:	e1 f7       	brne	.-8      	; 0x430 <__EEPROM_REGION_LENGTH__+0x30>
 438:	00 c0       	rjmp	.+0      	; 0x43a <__EEPROM_REGION_LENGTH__+0x3a>
 43a:	00 00       	nop
 43c:	e3 cf       	rjmp	.-58     	; 0x404 <__EEPROM_REGION_LENGTH__+0x4>

0000043e <__mulsi3>:
 43e:	db 01       	movw	r26, r22
 440:	8f 93       	push	r24
 442:	9f 93       	push	r25
 444:	0e 94 70 02 	call	0x4e0	; 0x4e0 <__muluhisi3>
 448:	bf 91       	pop	r27
 44a:	af 91       	pop	r26
 44c:	a2 9f       	mul	r26, r18
 44e:	80 0d       	add	r24, r0
 450:	91 1d       	adc	r25, r1
 452:	a3 9f       	mul	r26, r19
 454:	90 0d       	add	r25, r0
 456:	b2 9f       	mul	r27, r18
 458:	90 0d       	add	r25, r0
 45a:	11 24       	eor	r1, r1
 45c:	08 95       	ret

0000045e <__udivmodsi4>:
 45e:	a1 e2       	ldi	r26, 0x21	; 33
 460:	1a 2e       	mov	r1, r26
 462:	aa 1b       	sub	r26, r26
 464:	bb 1b       	sub	r27, r27
 466:	fd 01       	movw	r30, r26
 468:	0d c0       	rjmp	.+26     	; 0x484 <__udivmodsi4_ep>

0000046a <__udivmodsi4_loop>:
 46a:	aa 1f       	adc	r26, r26
 46c:	bb 1f       	adc	r27, r27
 46e:	ee 1f       	adc	r30, r30
 470:	ff 1f       	adc	r31, r31
 472:	a2 17       	cp	r26, r18
 474:	b3 07       	cpc	r27, r19
 476:	e4 07       	cpc	r30, r20
 478:	f5 07       	cpc	r31, r21
 47a:	20 f0       	brcs	.+8      	; 0x484 <__udivmodsi4_ep>
 47c:	a2 1b       	sub	r26, r18
 47e:	b3 0b       	sbc	r27, r19
 480:	e4 0b       	sbc	r30, r20
 482:	f5 0b       	sbc	r31, r21

00000484 <__udivmodsi4_ep>:
 484:	66 1f       	adc	r22, r22
 486:	77 1f       	adc	r23, r23
 488:	88 1f       	adc	r24, r24
 48a:	99 1f       	adc	r25, r25
 48c:	1a 94       	dec	r1
 48e:	69 f7       	brne	.-38     	; 0x46a <__udivmodsi4_loop>
 490:	60 95       	com	r22
 492:	70 95       	com	r23
 494:	80 95       	com	r24
 496:	90 95       	com	r25
 498:	9b 01       	movw	r18, r22
 49a:	ac 01       	movw	r20, r24
 49c:	bd 01       	movw	r22, r26
 49e:	cf 01       	movw	r24, r30
 4a0:	08 95       	ret

000004a2 <__divmodsi4>:
 4a2:	05 2e       	mov	r0, r21
 4a4:	97 fb       	bst	r25, 7
 4a6:	1e f4       	brtc	.+6      	; 0x4ae <__divmodsi4+0xc>
 4a8:	00 94       	com	r0
 4aa:	0e 94 68 02 	call	0x4d0	; 0x4d0 <__negsi2>
 4ae:	57 fd       	sbrc	r21, 7
 4b0:	07 d0       	rcall	.+14     	; 0x4c0 <__divmodsi4_neg2>
 4b2:	0e 94 2f 02 	call	0x45e	; 0x45e <__udivmodsi4>
 4b6:	07 fc       	sbrc	r0, 7
 4b8:	03 d0       	rcall	.+6      	; 0x4c0 <__divmodsi4_neg2>
 4ba:	4e f4       	brtc	.+18     	; 0x4ce <__divmodsi4_exit>
 4bc:	0c 94 68 02 	jmp	0x4d0	; 0x4d0 <__negsi2>

000004c0 <__divmodsi4_neg2>:
 4c0:	50 95       	com	r21
 4c2:	40 95       	com	r20
 4c4:	30 95       	com	r19
 4c6:	21 95       	neg	r18
 4c8:	3f 4f       	sbci	r19, 0xFF	; 255
 4ca:	4f 4f       	sbci	r20, 0xFF	; 255
 4cc:	5f 4f       	sbci	r21, 0xFF	; 255

000004ce <__divmodsi4_exit>:
 4ce:	08 95       	ret

000004d0 <__negsi2>:
 4d0:	90 95       	com	r25
 4d2:	80 95       	com	r24
 4d4:	70 95       	com	r23
 4d6:	61 95       	neg	r22
 4d8:	7f 4f       	sbci	r23, 0xFF	; 255
 4da:	8f 4f       	sbci	r24, 0xFF	; 255
 4dc:	9f 4f       	sbci	r25, 0xFF	; 255
 4de:	08 95       	ret

000004e0 <__muluhisi3>:
 4e0:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <__umulhisi3>
 4e4:	a5 9f       	mul	r26, r21
 4e6:	90 0d       	add	r25, r0
 4e8:	b4 9f       	mul	r27, r20
 4ea:	90 0d       	add	r25, r0
 4ec:	a4 9f       	mul	r26, r20
 4ee:	80 0d       	add	r24, r0
 4f0:	91 1d       	adc	r25, r1
 4f2:	11 24       	eor	r1, r1
 4f4:	08 95       	ret

000004f6 <__umulhisi3>:
 4f6:	a2 9f       	mul	r26, r18
 4f8:	b0 01       	movw	r22, r0
 4fa:	b3 9f       	mul	r27, r19
 4fc:	c0 01       	movw	r24, r0
 4fe:	a3 9f       	mul	r26, r19
 500:	70 0d       	add	r23, r0
 502:	81 1d       	adc	r24, r1
 504:	11 24       	eor	r1, r1
 506:	91 1d       	adc	r25, r1
 508:	b2 9f       	mul	r27, r18
 50a:	70 0d       	add	r23, r0
 50c:	81 1d       	adc	r24, r1
 50e:	11 24       	eor	r1, r1
 510:	91 1d       	adc	r25, r1
 512:	08 95       	ret

00000514 <__itoa_ncheck>:
 514:	bb 27       	eor	r27, r27
 516:	4a 30       	cpi	r20, 0x0A	; 10
 518:	31 f4       	brne	.+12     	; 0x526 <__itoa_ncheck+0x12>
 51a:	99 23       	and	r25, r25
 51c:	22 f4       	brpl	.+8      	; 0x526 <__itoa_ncheck+0x12>
 51e:	bd e2       	ldi	r27, 0x2D	; 45
 520:	90 95       	com	r25
 522:	81 95       	neg	r24
 524:	9f 4f       	sbci	r25, 0xFF	; 255
 526:	0c 94 96 02 	jmp	0x52c	; 0x52c <__utoa_common>

0000052a <__utoa_ncheck>:
 52a:	bb 27       	eor	r27, r27

0000052c <__utoa_common>:
 52c:	fb 01       	movw	r30, r22
 52e:	55 27       	eor	r21, r21
 530:	aa 27       	eor	r26, r26
 532:	88 0f       	add	r24, r24
 534:	99 1f       	adc	r25, r25
 536:	aa 1f       	adc	r26, r26
 538:	a4 17       	cp	r26, r20
 53a:	10 f0       	brcs	.+4      	; 0x540 <__utoa_common+0x14>
 53c:	a4 1b       	sub	r26, r20
 53e:	83 95       	inc	r24
 540:	50 51       	subi	r21, 0x10	; 16
 542:	b9 f7       	brne	.-18     	; 0x532 <__utoa_common+0x6>
 544:	a0 5d       	subi	r26, 0xD0	; 208
 546:	aa 33       	cpi	r26, 0x3A	; 58
 548:	08 f0       	brcs	.+2      	; 0x54c <__utoa_common+0x20>
 54a:	a9 5d       	subi	r26, 0xD9	; 217
 54c:	a1 93       	st	Z+, r26
 54e:	00 97       	sbiw	r24, 0x00	; 0
 550:	79 f7       	brne	.-34     	; 0x530 <__utoa_common+0x4>
 552:	b1 11       	cpse	r27, r1
 554:	b1 93       	st	Z+, r27
 556:	11 92       	st	Z+, r1
 558:	cb 01       	movw	r24, r22
 55a:	0c 94 af 02 	jmp	0x55e	; 0x55e <strrev>

0000055e <strrev>:
 55e:	dc 01       	movw	r26, r24
 560:	fc 01       	movw	r30, r24
 562:	67 2f       	mov	r22, r23
 564:	71 91       	ld	r23, Z+
 566:	77 23       	and	r23, r23
 568:	e1 f7       	brne	.-8      	; 0x562 <strrev+0x4>
 56a:	32 97       	sbiw	r30, 0x02	; 2
 56c:	04 c0       	rjmp	.+8      	; 0x576 <strrev+0x18>
 56e:	7c 91       	ld	r23, X
 570:	6d 93       	st	X+, r22
 572:	70 83       	st	Z, r23
 574:	62 91       	ld	r22, -Z
 576:	ae 17       	cp	r26, r30
 578:	bf 07       	cpc	r27, r31
 57a:	c8 f3       	brcs	.-14     	; 0x56e <strrev+0x10>
 57c:	08 95       	ret

0000057e <_exit>:
 57e:	f8 94       	cli

00000580 <__stop_program>:
 580:	ff cf       	rjmp	.-2      	; 0x580 <__stop_program>
